---
title: "B-Tree Data Structure"
date: 2024-04-21T08:19:48+03:00
draft: false # Set 'false' to publish
tableOfContents: false # Enable/disable Table of Contents
description: ''
categories:
  - Data structures
tags:
  -
---

## Pseudocode is better than natural language

As you could notice in the [previous post](../blockchain-in-golang), I am learning about how to build some stuff. After I finised blockchain implementation, next item (in alphabetical order), was database. Databases, as well as file systems, work with persistent storage, where access speed is really slow compared to random acces memory. As it turns out, there is a really special data structure which is used when working with persistent storage. Namely, it is a [B-Tree](https://en.wikipedia.org/wiki/B-tree). I really not do algorithms that much because I am too stupid for that, but from time to time, I am forced to. This was the case. Time finally came to open [the book](https://mitpress.mit.edu/9780262046305/introduction-to-algorithms) yet again. Surprisingly, as it turns out, B-Trees are not as trendy as say, linked lists or hash tables, or binary search trees. So it is not that easy to find info about them. Book mentioned earlier covers pretty much the things that you would want to know about B-Trees. Of course, as always, definition is consists of some letters and formulas and equations, but I don't pay that much attention to all that stuff. The most important thing that you can know is that keys, just as in BST, act as separators between corresponding subtrees. Left subtree will contain values less than in the key, and right subtree will contain values greater than in the key. This principle had been expanded so that nodes now can contain multiple keys. 

Searching and inserting are covered fairly well in the book. But of course, there is a reason, why I would start to write this rant post. This is god damn deletion. Authors decided to make a big brain move: instead of the pseudocode, they gave a word description of the algorithms. I do not think, that there could exist any words that are suited for describing my pain and angst and anger. I knew what was coming for me. It was a really pain in the butt. With last scrapes of my poor mind left with me, I started to turn those words into code. It was not really clear for me at the beggining, what was meant by the description, that had been fairly vague at some points. For that reason, I searched information on the internet. Apparently, some Indian-origin instructor from MIT OCW put it fairly well on the example step by step. After some polishing, code was finally compiling. But wait... At the moment I saw long rows of big random numbers floating all over my screen, I knew that I screwed. It was a segfault.

I would like to elaborate on that moment here for some time. Of course, it is not like I was using C at the first time. Of course, I encountered and conquered countless segfaults before. But man, oh man, I barely can remember such painful segfault as this one. I honestly did not count precisely, but it was death loop, infinite cycle of frustration, procrastination and careful reading of the code again, and again, and again. It genuenly vividly reminded me of a quote about insanity. Countless reading and debugging sessions to start everything yet again. After some poking around I apparently found some code in Python. It was somewhat painful to translate between Python and C, but even after that I could not see the issue. I do not remember which time it was that I routinely launched my program at the debugger, probably more than tenth, when I decided carefully investigate issue step by step. At that point, it was like a lighting struck into my head: I deleted item manually, although instead of that it should have been let intact for successive recursive call. Essentially I made a weird assumption that I have to clean up before... Cleaning up? As soon as lines were purged from my code, I saw neat and nice aligned lines of numbers. Issue had been fixed.

To be fair, issue was not in the word description in this case, because this moment had been stated fairly clear: merge item onto the child before successive recursive call into that child. It was my personal mistake for *interpretation* of that action. It was fundamental flaw of my reasoning, and not mistake of the authors. In previous post I stated that code states very clear and precise meaning. So I have taken a shot to derive code from word description. Apparently, it was not that much hard, because authors used fairly clear description. But of course it was not enough still, because some places were not really clear either. But I think that the most dangerous thing that you can do is to allow freedom of *interpretation*. Because in this exact process lie countless number of logical flaws.
